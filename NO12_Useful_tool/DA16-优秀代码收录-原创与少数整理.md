
[滑动窗口](#滑动窗口)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[滑动窗口 leet239 滑动窗口最大值](#滑动窗口-leet239-滑动窗口最大值)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[滑动窗口之异位词 leet438](#滑动窗口之异位词-leet438)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[滑动窗口之无重复的最长子串](#滑动窗口之无重复的最长子串)<br/>
[链表](#链表)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[目录](#目录)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[list 链表 python ](#list-链表-python-)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[链表的排序和合并 leet148](#链表的排序和合并-leet148)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[leet234 回文链表的判断](#leet234-回文链表的判断)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[基于数组的回文的数量统计](#基于数组的回文的数量统计)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[LRUCache](#LRUCache)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)](#[146-LRU缓存机制](https://leetcode-cncom/problems/lru-cache/))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)](#[25-K-个一组翻转链表](https://leetcode-cncom/problems/reverse-nodes-in-k-group/))<br/>
[栈的问题](#栈的问题)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[leet42 小顶栈存水问题](#leet42-小顶栈存水问题)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[leet55 跳跃游戏](#leet55-跳跃游戏)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[leet32 最长的包含有效括号的子串的长度](#leet32-最长的包含有效括号的子串的长度)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/) 奇思妙想 ](#[除自身以外数组的乘积](https://leetcode-cncom/problems/product-of-array-except-self/)-奇思妙想-)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[哈夫曼编码问题](#哈夫曼编码问题)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[螺旋数组](#螺旋数组)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[4. 寻找两个有序数组的中位数]](#[4-寻找两个有序数组的中位数](https://leetcode-cncom/problems/median-of-two-sorted-arrays/))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[树的中序遍历](#树的中序遍历)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[leet53 最大子数组和](#leet53-最大子数组和)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)](#[53-最大子序和](https://leetcode-cncom/problems/maximum-subarray/))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[快排子排序应用来移动0](#快排子排序应用来移动0)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[重复数](#重复数)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)](#[287-寻找重复数](https://leetcode-cncom/problems/find-the-duplicate-number/))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[leet48 缺失的值](#leet48-缺失的值)<br/>
[位运算](#位运算)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[leet136 唯一出现的数字](#leet136-唯一出现的数字)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 唯一出现的两个数](#-唯一出现的两个数)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[两个数字相加的位运算](#两个数字相加的位运算)<br/>
[栈](#栈)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[最小栈-用一个栈实现的](#最小栈-用一个栈实现的)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[带*号的栈](#带*号的栈)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[字符串解压](#字符串解压)<br/>
[其他](#其他)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[区间合并 leet56](#区间合并-leet56)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[删除节点O(1) 给定头结点和一个指定的结点，要删除这个指定的结点](#删除节点O(1)-给定头结点和一个指定的结点，要删除这个指定的结点)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[全排列](#全排列)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[接雨水 leet42](#接雨水-leet42)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[打印n位数 剑指offer12](#打印n位数-剑指offer12)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[字节跳动周赛](#字节跳动周赛)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[1417. 重新格式化字符串](#1417-重新格式化字符串)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[字节跳动周赛 排列菜单](#字节跳动周赛-排列菜单)<br/>
[动态规划](#动态规划)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[最长递增子序列 递增序列 leet300](#最长递增子序列-递增序列-leet300)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)](#[300-最长上升子序列](https://leetcode-cncom/problems/longest-increasing-subsequence/))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[摇筛子(骰子)结果统计](#摇筛子(骰子)结果统计)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[动态规划方法](#动态规划方法)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[牛妹的礼物](#牛妹的礼物)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[leetcode416 等和子集](#leetcode416-等和子集)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)](#[416-分割等和子集](https://leetcode-cncom/problems/partition-equal-subset-sum/))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[打家劫舍最简单的版本](#打家劫舍最简单的版本)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[更简介的递归](#更简介的递归)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[动态规划](#动态规划)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ 打家劫舍2 环形](#-打家劫舍2-环形)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[买股票系列 允许一次交易 ](#买股票系列-允许一次交易-)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[股票交易，含1天冷冻期](#股票交易，含1天冷冻期)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)](#[309-最佳买卖股票时机含冷冻期](https://leetcode-cncom/problems/best-time-to-buy-and-sell-stock-with-cooldown/))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[定符号 leet494](#定符号-leet494)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[leet322 零钱兑换](#leet322-零钱兑换)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[莱文斯坦编辑距离](#莱文斯坦编辑距离)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[最长公共序列 leet1143](#最长公共序列-leet1143)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)](#[338-比特位计数](https://leetcode-cncom/problems/counting-bits/))<br/>
[树](#树)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[平衡树](#平衡树)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[树的直径](#树的直径)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[leet617 树的合并](#leet617-树的合并)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)](#[617-合并二叉树](https://leetcode-cncom/problems/merge-two-binary-trees/))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[从树的中序遍历、前序遍历重新构建树](#从树的中序遍历、前序遍历重新构建树)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[树的翻转](#树的翻转)<br/>
[排序](#排序)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[旋转数组的排序 leet153, 支持重复数字](#旋转数组的排序-leet153,-支持重复数字)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)](#[153-寻找旋转排序数组中的最小值](https://leetcode-cncom/problems/find-minimum-in-rotated-sorted-array/))<br/>
[递归](#递归)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[如何把全局变量变成局部变量](#如何把全局变量变成局部变量)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[leet394 字符串解码](#leet394-字符串解码)<br/>
[双指针](#双指针)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[3sum leet15](#3sum-leet15)<br/>
[字符串](#字符串)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[异位词分组 leet49](#异位词分组-leet49)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)](#[49-字母异位词分组](https://leetcode-cncom/problems/group-anagrams/))<br/>
[ 括号匹配](#-括号匹配)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[leet301 本机能通过，网页单例测试通过，提交无法通过 leetcode cn](#leet301-本机能通过，网页单例测试通过，提交无法通过-leetcode-cn)<br/>
[子数组](#子数组)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[leet560 连续子数组的和](#leet560-连续子数组的和)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)](#[560-和为K的子数组](https://leetcode-cncom/problems/subarray-sum-equals-k/))<br/>
[图](#图)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[ BFS](#-BFS)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)](#[200-岛屿数量](https://leetcode-cncom/problems/number-of-islands/))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[DAG的检测 leet207](#DAG的检测-leet207)<br/>
[矩阵](#矩阵)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[leetcode48 leet48](#leetcode48-leet48)<br/>



# 滑动窗口

***

### 滑动窗口 leet239 滑动窗口最大值

https://leetcode.com/problems/sliding-window-maximum/

[239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

**难度困难**330

给定一个数组 *nums*，有一个大小为 *k* 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 *k* 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

**进阶：**

你能在线性时间复杂度内解决此题吗？

 

**示例:**

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

 

**提示：**

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `1 <= k <= nums.length`

```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if nums == []: return [] 
        res = []
        pos = 0
        for i in range(0,k):
            if nums[i] >= nums[pos]:
                pos = i                
        res.append(nums[pos])    
        for i in range(1, len(nums)-k+1): # range 左开右闭，我们一定要注意这个问题！
            if i <= pos:
                if nums[i+k-1] <= nums[pos]:
                    res.append(nums[pos])                    
                else:
                    res.append(nums[i+k-1])
                    pos = i+k-1
            if i > pos:
                pos = i
                for j in range(i, i+k):
                    if nums[j] > nums[pos]:
                        pos = j  
                res.append(nums[pos])
        return res
```

****

***

### 滑动窗口之异位词 leet438

[438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

难度中等258

给定一个字符串 **s** 和一个非空字符串 **p**，找到 **s** 中所有是 **p** 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 **s** 和 **p** 的长度都不超过 20100。

**说明：**

- 字母异位词指字母相同，但排列不同的字符串。
- 不考虑答案输出的顺序。

**示例 1:**

```
输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。
```

 **示例 2:**

```
输入:
s: "abab" p: "ab"

输出:
[0, 1, 2]
```

```python
class Solution:
    def findAnagrams(self, s, p) :
        res = []
        left = 0
        cnt = 0
        cnt_map = {} # 是否包含所有字母
        s_map = {}
        for c in p:
            cnt_map[c] = cnt_map.get(c, 0) + 1
        for i in range(len(s)):
            s_map[s[i]] = s_map.get(s[i], 0) + 1
            if s_map[s[i]] == cnt_map.get(s[i], 0):
                cnt += 1
            while cnt == len(cnt_map):
                # 如果刚好合适，那么放入结果集
                if i - left + 1 == len(p): res.append(left)
                # 如果最左边的字母是必须的字母, 则当前窗口统计的这个字母的数量减1
                # 如果不是，那么就继续前进
                if cnt_map.get(s[left], 0) > 0:
                    s_map[s[left]] -= 1
                    if s_map.get(s[left]) < cnt_map.get(s[left]):
                        cnt -= 1
                left += 1
        return res
```

****

***

### 滑动窗口之无重复的最长子串

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left = right = 0
        window = {}
        res = 0
        # 从左向右滑动窗口
        while right < len(s):
            # widnow记录每一个字符串出现的位置
            if (window.get(s[right]) is None):
                window[s[right]] = right
                # 比较当前窗口大小和res值，以更大的值更新res
                res = max(res, right - left + 1)
                right += 1
            else:
                # 如果有重复的值，则修改left为当前字符最后一次出现的位置
                #   并且删掉left之前的键
                p = window.get(s[right])
                while left <= p:
                    del window[s[left]]
                    left += 1
        return res

```

滑动窗口的套路，就是先放宽条件，保证满足一个条件，然后再缩小窗口满足另一个条件。

****

# 链表

### 目录

- list转链表
- 链表的排序和合并 leet148
- leet234 回文链表的判断
- 

### list 链表 python 

```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

    # def __repr__(self):
    #     # return self.val + 'next is ' + self.next.val if self.next else 'None'
    #     return self.val
    #
    def __str__(self):
        return self.val
'''列表转链表'''
def make_linkedlist(list1):
    a = b = ListNode(0)
    for i in list1:
        b.next = ListNode(i)
        b = b.next
    return a.next

def print_linkedlist(listNode):
    if listNode is None:
        print('linkedlist is None')
    while listNode:
        print(listNode.val, end=",")
        listNode = listNode.next


ls = [1, 2, 3, 4, 5, 6]
lkls = make_linkedlist(ls)
print_linkedlist(lkls)


print('')

'''原地反转，非头插法'''
def reverse(head):
    if head is None:
        return None
    pre = None
    cur = head
    next = cur.next
    while next is not None:
        cur.next = pre
        pre = cur
        cur = next
        next = next.next
    cur.next = pre
    return cur
```

***

### 链表的排序和合并 leet148

在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

示例 1:

输入: 4->2->1->3
输出: 1->2->3->4
示例 2:

输入: -1->5->3->4->0
输出: -1->0->3->4->5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/sort-list
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```python
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        # 分治法解决
        if head is None or head.next is None: return head
        # 链表切割成两半
        slow = slow_pre = fast = head
        while fast and fast.next:
            slow_pre = slow
            slow = slow.next
            fast = fast.next.next
        slow_pre.next = None        
        # 两半分别进行归并排序
        return self.merge(self.sortList(head), self.sortList(slow))        
    
    def merge(self, list1, list2):
      	"""
      	链表的原地合并
      	"""
        dummy = rear = ListNode(0)
        while list1 and list2:
            if list1.val <= list2.val:
                rear.next = list1
                list1 = list1.next
            else:
                rear.next = list2
                list2 = list2.next
            rear = rear.next 
        if list1: rear.next = list1 
        if list2: rear.next = list2  
        return dummy.next
```

****



***

### leet234 回文链表的判断

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        # 获取长度
        tmp = head
        length = 0
        while tmp:
            length += 1
            tmp = tmp.next        
        # 获取中间点
        tmp = head
        half = (length+1)//2
        while half > 0:
            tmp = tmp.next
            half -= 1            
        # 反转链表
        tmp = self.reverse_linkedlist(tmp)
        # 逐一对照
        while tmp:
            if tmp.val != head.val:
                return False
            tmp = tmp.next
            head = head.next
        return True
       
    def reverse_linkedlist(self, head: ListNode)->ListNode:
        if head is None: return head
        dummy = ListNode(0)
        while head:
            tmp = head # 摘下来一个节点
            head = head.next # 保持原来节点的连贯性
            tmp.next = dummy.next
            dummy.next = tmp            
        return dummy.next            
```

****



***

### 基于数组的回文的数量统计

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        cnt = 0
        for i in range(len(s)):
            cnt += self.check(s, i, i)  # 奇数
            cnt += self.check(s, i, i + 1)  # 偶数
        return cnt
		
    def check(self, s, i, j):
      """
      统计回文的数量
      """
        cnt = 0
        length = len(s)
        while i > -1 and j < length and s[i] == s[j]:
            cnt += 1
            i -= 1
            j += 1
        return cnt
```

****



### LRUCache

***

#### [146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)

难度中等522

运用你所掌握的数据结构，设计和实现一个 [LRU (最近最少使用) 缓存机制](https://baike.baidu.com/item/LRU)。它应该支持以下操作： 获取数据 `get` 和 写入数据 `put` 。

获取数据 `get(key)` - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
写入数据 `put(key, value)` - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。


**进阶:**

你是否可以在 **O(1)** 时间复杂度内完成这两种操作？

 

**示例:**

```
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```

```python
# 注意，这个并没有实现 map 算法，需要双链表加上 map 算法
class LRUCache:    
    class Node:
        def __init__(self, k, v):
            self.v = v # value
            self.next = None
            self.pre = None 
            self.k = k # key            

    def __init__(self, capacity: int):
        # 维护一个双链表
        # 设计双链表结点的结构
        # 结点结构又能放入哈希表里面去
        # 检查
        self.capacity = capacity
        self.size = 0
        self.dummy = self.Node(-1,0) # 头节点和尾节点，方便处理         
        self.tail = self.Node(-1,0)     
        self.dummy.next = self.tail 
        self.tail.pre = self.dummy

    def get(self, key: int) -> int:
        nxt = self.dummy
        res_node = None
        # 遍历寻找
        while nxt and nxt is not self.tail:
            if nxt.k == key:
                res_node = nxt
                break
            nxt = nxt.next
        # 为空
        if res_node is None: return -1
        # 找到
        self.move_node(res_node) # 调整到第一个位置
        return res_node.v
    
    def put(self, key: int, value: int) -> None:
        # 先查找
        nxt = self.dummy.next
        res_node = None
        # 遍历寻找
        while nxt and nxt is not self.tail:
            if nxt.k == key:
                res_node = nxt
                break
            nxt = nxt.next
        # 找到更新并移位
        if res_node is not None:
            res_node.v = value
            self.move_node(res_node)
        # 没有找到
        # 没有找到则新建并放到头部         
        else:
            # 没有位置则删除最后一个   
            if self.size >= self.capacity:
                self.tail.pre.pre.next =self.tail
                self.tail.pre = self.tail.pre.pre   
                self.size -= 1           
            res_node = self.Node(key, value)
            self.insert_node(res_node)
            self.size += 1
    
    def insert_node(self, node):
        node.next = self.dummy.next
        node.pre = self.dummy
        self.dummy.next.pre = node
        self.dummy.next = node

    def move_node(self, node):
        if  node is self.dummy.next :
            return
        else:
            node.next.pre = node.pre
            node.pre.next = node.next
            # 如果是尾巴结点
        self.insert_node(node)
                        
# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```



使用列表实现

```python
class LRUCache:

    def __init__(self, capacity: int):
        self.ls = []
        self.size = 0
        self.capacity = capacity


    def get(self, key: int) -> int:
        pos = -1
        value = -1
        for i in range(self.size):
            if self.ls[i][0] == key:
                pos = i 
                value = self.ls[i][1]
        if pos != -1:     
            self.ls.pop(pos)      
            self.ls.insert(0, [key, value])            
        return value
            
    def put(self, key: int, value: int) -> None:
        pos = -1
        for i in range(self.size):
            if self.ls[i][0] == key:
                pos = i
                self.ls[i][1] = value
        if pos != -1:
            self.ls.pop(pos)            
        elif  self.size >= self.capacity and pos == -1:
            self.ls.pop()
        elif pos == -1:
            self.size += 1        
        self.ls.insert(0, [key, value])
```

基于字典的实现，实现了一半 TODO

```python
class LRUCache:

    def __init__(self, capacity: int):
        self.size = 0
        self.capacity = capacity
        self.the_map = {}
        self.head = -1
        self.tail = -2
        self.the_map[-1] = [None, None, -2]
        self.the_map[-2] = [None, -1, None]

    def get(self, key: int) -> int:
        value = -1
        if self.the_map.get(key):
            value = self.the_map.get(key)[0]
            self.move_to_head(key)
        reeturn value
                        
    def put(self, key: int, value: int) -> None:
        if self.the_map.get(key):
            self.the_map[key][0] = value
        elif self.size < self.capacity: 
            self.the_map[key] = [value, -1, -1]
            self.size += 1
        else:
            self.the_map.pop(self.tail)
            self.the_map[key] = [value, -1, -1]
        self.move_to_head(key)

    def move_to_head(self, key):
        key_node = self.the_map.get(key)
        self.the_map.get(key_node[1])[2] = key_node[2]
        self.the_map.get(key_node[2])[1] = key_node[1]

# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```

****



***

### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        while True:
            pre_head = head
            head = self.helper(head, k)
            if head == pre_head:
                break
        # 是在没有办法，只能
        for i in range(1, len(self.section)):
            self.section[i-1][1].next = self.section[i][0]
        return self.header or head

    header = None
    section = []

    def helper(self, head, k):
        if head is None:
            return None
        rear = rear2 = head
        length = 0
        while rear and length < k:
            length += 1
            rear = rear.next
        if length < k:
            self.section.append([head, rear2])  # 增加前序序列
            return head
        dummy = ListNode(0)
        i = 0
        while i < k:
            tmp = head
            head = head.next
            tmp.next = dummy.next
            dummy.next = tmp
            i += 1
        self.section.append([dummy.next, rear2])  # 增加前序序列
        if self.header is None:
            self.header = dummy.next
        return head
```



改进版

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        # 采用顺序遍历的思路
        # 每次先拿k个结点，然后对这个k个结点进行翻转
        # 然后再对剩下的进行同样的操作
        if not head: return None
        length = 0
        tail = head
        while tail:
            tail = tail.next
            length += 1

        while length > k:
            pre_head = head
            pre = None
            # 截取k个结点作为一段链表
            for i in range(k):
                pre = head
                head = head.next
            pre.next = None
            self.helper(pre_head)
            length -= k
        self._tail.next = head
        return self._dummy.next

    _dummy = _tail = ListNode(0)

    def helper(self, head):
        dummy = ListNode(0)
        tail = head
        while head:
            tmp = head
            head = head.next
            tmp.next = dummy.next
            dummy.next = tmp
        self._tail.next = dummy.next
        self._tail = tail


import lib
lkls = lib.make_linkedlist([1,2,3,4,5])
head = Solution().reverseKGroup(lkls, 6)
lib.print_linkedlist(head)

```

****

# 栈的问题

***

### leet42 小顶栈存水问题

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        stack = []
        res = 0
        i = 0
        while i < len(height):
            if len(stack)==0 or height[i] <= height[stack[-1]]:
                stack.append(i)
                i+=1
            else:
                low_index = stack.pop()
                if len(stack)==0: continue
                # 这一句太复杂了！！
                res += (min(height[i], height[stack[-1]])-height[low_index])*(i-stack[-1]-1) 
        return res
```

****



***

### leet55 跳跃游戏

倒数

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:        
        reach = len(nums) - 1
        for i in range(reach-1, -1, -1): # 经典的从后往前有奇迹！！
            if  reach - i > nums[i]  : continue
            else:
                reach = i
        return reach == 0
```

****



***

### leet32 最长的包含有效括号的子串的长度

32. 最长有效括号
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:

输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
示例 2:

输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"

难度困难 

给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。

**示例 1:**

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

**示例 2:**

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

失败的算法
```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        lc = rc = res = left = 0 # 左右括号的数量都初始化为0
        # 如果当前字符为左括号，左括号的数量 >=右括号，合法
        # 如果是右括号，而且右括号的数量大于左括号，非法，本字符串结束
        while s[0] == ')': s = s[1:]
        while s[-1] == '(': s = s[:-1]
        length = len(s)
        for i in range(length):
            if s[i] == '(':
                lc += 1
            else:
                if rc+1 > lc:
                    res = max(res, i-left)
                    lc = rc = 0
                    left = i+1
                else:
                    rc += 1
        i = left
        while i < length:
            if s[i] == ')':
                left += 1
                rc -= 1
                i += 1
            elif lc > rc and s[i] == '(':
                left += 1
                lc -= 1
                i += 1
            else:
                break
        res = max(res, length-left)
        return res

if __name__ == '__main__':
    # s = ")()(((())))("
    s = "(())()(()((" # 没有考虑特殊情况
    Solution().longestValidParentheses(s)
    这个题不适合使用滑动窗口
```

```python
# 清单1
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        left = 0 # 这个left很关键
        res = 0
        stack = []
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)# 存储位置
            elif len(stack) == 0:
                    left = i+1
            else:
                top = stack.pop()
                if len(stack) == 0:
                    res = max(i - left +1, res)
                else:
                    res = max(res, i-stack[-1]) # 【-1】表示栈顶
        return res
```

描述如下：

1. 初始化一个空栈stack, 一个表示可能的合法子串的起始下标left，一个保存子串最大长度值的变量res

2. 遍历字符串的每一个字符：

   A. 如果是 左括号，那么压栈

   B. 如果是右括号，分两种情况讨论：

   (1) 如果是空栈，那么说明这个字符导致前面的合法字符串在这个位置停止，重置left 的值为下一个位置。

   (2) 如果不是空栈，那么弹出栈顶的左括号与之匹配，低效，并重新计算res的值，res每次遇到匹配的串都是值在逐步扩大的。res的值计算又分两种情况计算，具体情况见代码。

3. 输出遍历完成后的res的值。

****



***

### [除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/) 奇思妙想 

```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        # 建立两个数组，分别是一个元素之前所有的元素的乘积 p1，另一个是一个元素之后元素的乘积 p2
        # p1 使用 顺序遍历， p2 使用后序遍历
        # 默认从1 开始
        res = []
        product = 1
        length = len(nums)
        p1 = [1] * length
        p2 = [1] * length
        # 生成p1
        for i in range(length):
            p1[i] = product
            product *= nums[i]
        # 倒序遍历生成p2
        product = 1
        for i in range(length-1, -1, -1):
            p2[i] = product
            product *= nums[i]
        # 生成res
        for i in range(length):
            res.append(p1[i] * p2[i])
        return res

```

****



***

### 哈夫曼编码问题

一种错误的编码，类似于但却不是哈夫曼编码

```python
a = [(30, 'a'), (40, 'b'), (50, 'c'), (200, 'd'), (210, 'e')] # 测试用例
a.sort(key=lambda item:item[0])
print(a)
# 首先，根据频率拍个序
# 根据a映射生成一个列表，记录 列表a 对应位置的频率前N项的累和
# 逆序遍历列表a，然后每次取出a最后一项 t，然后判断 t 的频率是否大于其一半，如果超过或者等于一半，令其编码为0， 否则为1
#   并且把结果加入到字典 res 中去.
# 循环递归，直到a的最后一项

def like_haffman_code(ls):
    if ls is None or ls == []: return {}
    ls.sort(key=lambda item: item[0])
    length = len(ls)
    freq = [item[0] for item in ls]
    _sum = 0
    for i in range(length):
        freq[i] += _sum
        _sum += freq[i]

    res = {}
    def encode(index, prefix):
        # 如果是最后一项, 我们直接令其编码为本次调用传过来的前缀参数即可
        # 否则我们判断该位置的频率是否大于对应位置频率累和的一半
        if index == 1:
            res[ls[1][1]] = prefix + '1'
            res[ls[0][1]] = prefix + '0'
            return
        if ls[index][0] * 2 > freq[index]:
            res[ls[index][1]] = prefix + '0'
            another = '1'
        else:
            res[ls[index][1]] = prefix + '1'
            another = '0'
        encode(index-1, prefix + another)

    encode(length-1, '')
    return res
```



正确的哈夫曼编码

```python
class TreeNode:
    """
    树的节点
    """
    def __init__(self, k, v):
        self.key = k
        self.val = v
        self.left = None
        self.right = None

def huffman_code(ls):
    # 1. 先取队列里两个最小键值结点, 构成一棵树(也叫做一个结点), 然后再放回去
    # 1.1 左子树的编码为0, 右子树的编码为1, 左子树小, 右子树大
    # 2 如果优先级队列只剩一个结点,弹出那个结点, 结束编码
    # 3 循环遍历最后的那个结点表示的树
    if ls is None or ls == []: return {}
    q = PriorityQueue(key=lambda item: item.val)
    for item in ls:
        q.append(TreeNode(item[0], item[1]))
    while q.size > 1:
        l, r = q.pop(2)
        new = TreeNode('', l.val + r.val)
        new.left = l
        new.right = r
        q.append(new)
    root = q.pop()

    res = {}
    def traverse(root, prefix):
        if root is None: return
        if root.left is None and root.right is None:
            res[root.key] = prefix
            return
        traverse(root.left, prefix+'0')
        traverse(root.right, prefix+'1')

    traverse(root, '')
    return res


class PriorityQueue:
    """
    一个低配版优先级队列, 本应通过堆来实现的
    """

    def __init__(self, key=None):
        """
        如果要实现对数字的逆序排序, 可以使用如下示例:
            q = PriorityQueue(lambda x:-x)
        :param key:
        """
        self.queue = []
        self.key = key

    def append(self, item):
        """这里有一个问题, 如果频繁插入, 那么就会很浪费时间,所以真正性能好还是要用堆来实现"""
        self.queue.append(item)
        self.queue.sort(key=self.key)

    def pop(self, n=1):
        if n == 1: return self.queue.pop(0)
        """最多"""
        i = 0
        res = []
        size = len(self.queue)
        while i < n and i < size:
            res.append(self.queue.pop(0))
            i += 1
        return res

    @property
    def size(self):
        return len(self.queue)


test1 = [('a', 30), ('b', 40), ('c', 50), ('d', 200), ('e', 210)]
test2 = [('a', 450), ('b', 350), ('c', 90), ('d', 60), ('e', 30), ('f', 20)]
print(huffman_code(test2))

```

****



***

### 螺旋数组

```python
def roll_matrix(matrix):
    length = len(matrix)

    row = 0
    col = length-1
    start = 1
    while row <= col:
      	# 其实都是找下标变化的规律而已，j表示列，表示行
        for j in range(row, col):
            matrix[row][j] = start
            start += 1

        for i in range(row, col):
            matrix[i][col] = start
            start += 1

        for j in range(col, row, -1):
            matrix[col][j] = start
            start += 1

        for i in range(col, row, -1):
            matrix[i][row] = start
            start += 1

        row += 1
        col -= 1

    if length % 2 == 1:
        matrix[length//2][length//2] = length * length

def roll_matrix_read(matrix):
    length = len(matrix)
    res = []
    row = 0
    col = length-1
    while row <= col:
        for j in range(row, col):
            res.append(matrix[row][j])
        for i in range(row, col):
            res.append(matrix[i][col])
        for j in range(col, row, -1):
            res.append(matrix[col][j])
        for i in range(col, row, -1):
            res.append(matrix[i][row])
        row += 1
        col -= 1
    if length % 2 == 1:
        res.append(matrix[length//2][length//2])
    return res

n = 7
matrix = [ [0 for i in range(n)] for j in range(n) ]
import lib
lib.printMatrix(matrix)
roll_matrix(matrix)
lib.printMatrix(matrix)
print(roll_matrix_read(matrix))
```

****



***

### [4. 寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)



4. 寻找两个有序数组的中位数
给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5

```python
List = list
class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        len1 = len(nums1)
        len2 = len(nums2)
        if (len1 + len2)%2 == 1: # 奇数和偶数不同
            return self.findKSmallest(nums1, 0, nums2, 0, (len1+len2+1)//2)
        else:
            return (self.findKSmallest(nums1, 0, nums2, 0, (len1+len2+1) // 2) + \
                self.findKSmallest(nums1, 0, nums2, 0, (len1+len2+2)//2)) / 2


    def findKSmallest(self, nums1, i, nums2, j, k):
        # 寻找第K小的数据
        # 首先比较两个数组第 k/2 项，如果哪一个数组的第 k/2 项小了，
        #   那么这个数据的前 k/2 项都要被淘汰，同时 k -= k/2
        # 如果一个数组为空，或者当前数组指向最末端， 那么只要找另一个数组就好了
        len1 = len(nums1)
        len2 = len(nums2)
        if len1-i < len2-j: # nums1 剩下的要短，nums2剩下的要长
            return self.findKSmallest(nums2, j, nums1, i, k)
        # int i = min(m, k / 2), j = min(n, k / 2);
        if j >= len2: # 越界
            return nums1[i + k-1]
        if k==1:
            return min(nums1[i], nums2[j])
        n = min(len1-i, k//2)
        m = min(len2-j, k//2) # 可以操作的长度
        if nums1[i+n-1] <= nums2[j+m-1]:
            return self.findKSmallest(nums1, i+n, nums2, j, k - n)
        else:
            return self.findKSmallest(nums1, i, nums2, j+m, k - m)

if __name__ == '__main__':
    Solution().findMedianSortedArrays([1,3], [2])
```

****



***

### 树的中序遍历

```python
from lib import TreeNode, list_to_tree

def traverse_left_first(root):
    # 我们的思路
    if root is None: return []
    res = []
    s = []
    visit_left = {} # 记忆用的，非常好用
    s.append(root)
    while len(s) > 0:
        t = s[-1]
        while t and t.left and not visit_left.get(t, False):
            visit_left[t] = True
            s.append(t.left)
            t = t.left
        if t.left is None or visit_left.get(t, False):
            res.append(s.pop().val)
        if t.right is not None:
            s.append(t.right)
    return res


if __name__ == '__main__':
    # ls = [1, 2, 3, 4, 5, 6, 7]
    # ls = [1, 2, None, 3]
    ls = [1, None, 2, None, None, 3, 4]

    root = list_to_tree(ls)
    res = traverse_left_first(root)
    print(res)

```

****



***

### leet53 最大子数组和

#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

难度简单1875

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例:**

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶:**

如果你已经实现复杂度为 O(*n*) 的解法，尝试使用更为精妙的分治法求解。

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if nums == []: return 0
        the_sum = res = nums[0]
        # 一定要学会按步骤分析，把自己的想法编程代码，特别是在循环体里面的每一步循环，第一步是什么，第二部是什么，这非常重要
        for i in range(1, len(nums)):
            if the_sum + nums[i] > nums[i]:  # if the_sum > 0：
                the_sum += nums[i]
            else:
                the_sum = nums[i]
            res = max(res, the_sum)
        return res 
        
```

****



***

### 快排子排序应用来移动0

```python
def move_zeros(ls):
    # 把 0 移动后后面去
    length = len(ls)
    if length == 0: return ls
    l = 0
    r = length - 1
    t = ls[0]
    while l < r:
        while l < r and ls[r] == 0: r -= 1
        ls[l] = ls[r]
        l += 1 # 已经换过的就不用再比较了, 这个位置肯定不是0, 往右边前进一位
        while l < r and ls[l] != 0: l += 1
        ls[r] = ls[l]
        r -= 1 # 同理,r的位置已经别放置为0了,不用再判断是不是0了,往左边移动一位
    ls[l] = t


num = [0, 0, 0, 0, 1, 0, 0, 1]
move_zeros(num)
print(num)
```

****



***

### 重复数

#### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

难度中等 539

给定一个包含 *n* + 1 个整数的数组 *nums*，其数字都在 1 到 *n* 之间（包括 1 和 *n*），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

**示例 1:**

```
输入: [1,3,4,2,2]
输出: 2
```

**示例 2:**

```
输入: [3,1,3,4,2]
输出: 3
```

**说明：**

1. **不能**更改原数组（假设数组是只读的）。
2. 只能使用额外的 *O*(1) 的空间。
3. 时间复杂度小于 *O*(*n*2) 。
4. 数组中只有一个重复的数字，但它可能不止重复出现一次。

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        # 这道题不能用暴力破解，否则时间复杂度就超了
        # 根据这道题的特点，我们只用找到那个值，而不用知道它在哪里
        # 我们采用 “基于数值的二分法”
        # 首先，我们找到中值，然后扫描小于等于中值前一半的元素的数量，如果大于一半，那么说明
        #   就在前一半数字里面有重复值，反之亦然
        r = len(nums) - 1
        l = 1             
        cnt = 0
        while l < r:
            mid = (l + r) // 2  
            for item in nums:
                if l <= item <= mid:
                    cnt += 1
            # 如果大于mid，那么就在前一半里面，否则在后一半里面
            if cnt > mid - l + 1:
                r = mid 
            else:
                l = mid + 1 
            cnt = 0
        return l                             
```

****



***

### leet48 缺失的值

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        # 思路是这样子的，首先，把所有的元素的值减去1当做下标，因为下标从0开始，
        # 然后把下标对应的值变为负数
        # 第二轮循环的时候，如果发现某一个下标对应的值为正数，那么说明了什么呢？说明这个下标的值没有对应的数字去调整它，所以这个下标 +1 就是缺失的值。
        res = []
        for item in nums:
            abs_item = abs(item)
            nums[abs_item-1] = - nums[abs_item-1] if nums[abs_item-1] > 0 else nums[abs_item-1]
        for i in range(len(nums)):
            if nums[i] > 0:
                res.append(i+1)
        return res
```

****





# 位运算



***

### leet136 唯一出现的数字

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        # 0 和 任何数异或都等于那个数
        # 任何数字和自己异或都等于0
        # 异或满足交换律
        # 0000 ^ 1010 = 1010
        # 0 ^ 0 = 0, 前两个表示0本身，最后一个表示 一样
        # 异或，就是比较是否不一样
        res = 0
        for item in nums:
            res = res ^ item
        return res
```

###  唯一出现的两个数

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        # 考察位运算 
        # 1. a xor a = 0, 
        # 2. a xor b = c, 那么c的至少某一位必然不等于0，所以利用这一位可以把 ab分离
        res = []
        t = 0
        for item in nums:
            t = t ^ item
        i = 0 
        # 确定第i位是1
        while True:
            if t & 1 << i != 0:
                break
            i += 1
        t2 = 0
        t3 = 0
        for item in nums:
            if item & 1 << i != 0:
                t2 = t2 ^ item
            else:
                t3 = t3 ^ item        
        res.append(t2)
        res.append(t3)
        return res
    
```



### 两个数字相加的位运算

```python

def bit_add(num1, num2):
    res = num1 ^ num2
    carry = num1 & num2
    while carry != 0:
        tmp = res
        res = (carry << 1) ^ res
        carry = (carry << 1) & tmp
    return res

res = bit_add(1, 100)
print(res)
```

****

LeetCode 137

```
res = 0
for i in range(4):
    res |= 1<<i
print(res)
```

请问输入结果是多少? 结果是15.  
1 | 10 | 100| 1000 = 1111, 按位或, 不涉及进位. (太奇怪了, 但这就是规则!)  

如何判断一个数n(二进制表示的数)的某一位(从低位开始数, 第i位)是不是1?  
`n>>i & 1 == 1`  
位运算的优先级是非常高的.  
n>>i 表示n(二进制)除以2的i次方  





# 栈

***

### 最小栈-用一个栈实现的

```python
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack =[]
        self.min_value = None

    def push(self, x: int) -> None:
        if len(self.stack) == 0:
            self.min_value = x
        # 如果现在压入的值小于等于最小值，那么在压入之前，先备份一下之前的最小值
        if x <= self.min_value: # 这个小于等于是最优价值的东西，记住了！！，一定要小于等于，不能是小于
            self.stack.append(self.min_value)
            self.min_value = x
        self.stack.append(x)


    def pop(self) -> None:
        if len(self.stack) <= 0:
            return None
        t = self.stack.pop()
        if t == self.min_value: # 因为这里是 == 比较，所以在push的时候，不光小于，等于也要压进去。说白了还是为了兼容，下限决定麻烦程度         
            self.min_value = self.stack.pop() # 把备份的最小值也弹出来
        return t

    def top(self) -> int:
        if len(self.stack) <= 0:
            return None
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_value



# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```

****



***

### 带*号的栈

```
给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：

任何左括号 ( 必须有相应的右括号 )。
任何右括号 ) 必须有相应的左括号 ( 。
左括号 ( 必须在对应的右括号之前 )。
* 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。
一个空字符串也被视为有效字符串。
示例 1:

输入: "()"
输出: True
示例 2:

输入: "(*)"
输出: True
示例 3:

输入: "(*))"
输出: True
注意:

字符串大小将在 [1，100] 范围内。

```

```python
cases = []

cases.extend([
    ["**)(", False],
    ["**)", True],
    ["(**)(", False],
    ["((**)", True],
    ["((**))))", True],
    ["", True],
    ["**))*", True]
])


class Solution:
    def check_sequence(self, the_str):
        # 两个栈, 第一个存左括号的下标,第二个存 * 的下标
        s1 = []
        s2 = []
        length = len(the_str)
        for i in range(length):
            if the_str[i] == '(':
                s1.append(i)
            elif the_str[i] == '*':
                s2.append(i)
            elif the_str[i] == ')':
                if len(s1) > 0: s1.pop()
                elif len(s2) > 0: s2.pop()
                else:
                    return False
				# 检测 * 是否能匹配
        while len(s1) > 0 and len(s2) > 0:
            if s2.pop() < s1.pop():
                return False
        if len(s1) > 0:
            return False
        return True


solution = Solution()
for case in cases:
    assert solution.check_sequence(case[0]) == case[1]


```

****



***

### 字符串解压

```python
from typing import List


class Solution:
    def decodeString(self, s: str) -> str:
        # 重复子问题，非常适合用递归来做
        if not s:return ''
        if not '[' in s:return s
        i = 0
        length = len(s)

        if i < length and (s[i] < '0' or s[i] > '9' ):
            j = i
            while j < length and ( s[j] < '0' or s[j] > '9' ):
                j += 1
            return s[i:j] + self.decodeString(s[j:])
        count = 0

        while i < length and s[i] >= '0' and s[i] <= '9':
            count =  count*10 + int(s[i])
            i += 1
        j = i+1
        l_pc = 0
        while j < length:
            if s[j] == '[': l_pc += 1
            elif s[j] == ']' and l_pc > 0: l_pc -= 1
            elif s[j] == ']': break
            j += 1
        return count * self.decodeString(s[i+1:j]) + self.decodeString(s[j+1:])


s = '2[abc]3[cd]ef'
res = Solution().decodeString(s)
print(res)
```

****



# 其他

***

### 区间合并 leet56

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        # 测试用例
        # 1. [1,2], [2, 3], [2,3]
        # 2. [1, 4], [2, 3]
        # 3. [1,10], [11, 15]
        # 4. [1, 1], [2, 2], [2, 3]
        # 5. []
        # 思路：设置一个结果集 res, 取第一个元素放入里面，从interval第二个元素开始遍历
        # 每次和 res 里面的最后一个元素比较   
        res = []
        length = len(intervals)
        if length ==0: return res   
        # 清晰垃圾数据，比如[], [1, 1]这样的数据
        # 假定：删掉所有空区间，也就是没有左   右区间的区间，这里我们假定区间合法 
        # 先给inteval 排序
        intervals.sort(key=lambda x: x[0])
        res.append(intervals[0])
        for i in range(1, length):
            top = res[-1]
            if intervals[i][0] <= top[1]: # 有重合
                if intervals[i][1] <= top[1]: # 完全重合
                    continue
                else:
                    top[1] = intervals[i][1]
            else:
                res.append(intervals[i])
        return res
         
```

****



***

### 删除节点O(1) 给定头结点和一个指定的结点，要删除这个指定的结点

```python
from lib import ListNode, make_linkedlist, print_linkedlist
def remove_node_in_lk(head, to_delete):
    if to_delete.next is not None: # 不是尾节点
        to_delete.val = to_delete.next.val
        to_delete.next = to_delete.next.next
    else: # 是尾节点
        cur = head
        while cur is not None:
            if cur.next == to_delete:
                cur.next = None
            cur = cur.next
    return head

ls = [1, 2, 3, 4]
lkls = make_linkedlist(ls, dummy=True)
print_linkedlist(lkls)
to_delete = lkls.next.next.next.next
remove_node_in_lk(lkls, to_delete)
print_linkedlist(lkls)

```

****





### 全排列

```python
def f1(strs):
    container = []
    f2('', strs, container)
    return container


def f2(cur, to_choose, container):
    if len(to_choose) == 1:
        container.append(cur + to_choose)
        return
    i = 0
    while i < len(to_choose):
        if i == 0:
            tmp = to_choose[1:]
        elif i == len(to_choose) - 1:
            tmp = to_choose[:-1]
        else:
            tmp = to_choose[:i] + to_choose[i+1:]
        f2(cur + to_choose[i], tmp, container)
        i += 1


if __name__ == '__main__':
    res = f1('abcd')
    print(res)

```



***

### 接雨水 leet42

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # version1 使用暴力解法, 这个会超出时间限制
        # 搜索左右两边的最高距离 l_highest, r_highest, 取更小的
        # 然后减去自身的高度
        length = len(height)
        if length == 0: return 0
        res = 0
        for i in range(length):
            l_highest = height[i]
            r_highest = height[i]
            for j in range(0, i):
                l_highest = max(l_highest, height[j])
            for j in range(i+1, length):
                r_highest = max(r_highest, height[j])
            res += min(l_highest, r_highest) - height[i]
        return res           
```

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        # version2 使用暴力解法的基础上，先算好l_highest, r_highest
        # 搜索左右两边的最高距离 l_highest, r_highest, 取更小的
        # 然后减去自身的高度
        length = len(height)
        if length == 0: return 0
        res = 0
        l_highest = [height[0] for i in range(length)]
        r_highest = [height[length-1] for i in range(length)]
        
        for i in range(1, length):
            l_highest[i] = max(l_highest[i-1], height[i])
        for i in range(length-2, -1, -1):
            r_highest[i] = max(r_highest[i+1], height[i])            
        for i in range(length):
            res += min(l_highest[i], r_highest[i]) - height[i]
        return res            
```



```python

class Solution:
    def trap(self, height: List[int]) -> int:
        # version3 使用递减栈来解决问题
        length = len(height)
        if length == 0: return 0
        res = 0
        s = []
        i = 0
        while i < length:
            if len(s) == 0 or height[i] <= height[s[-1]]: # 相等或者递减都压栈
                s.append(i) # 存下标
                i += 1
            else:                                
                top_i = s.pop()
                while len(s) > 0 and height[top_i] == height[s[-1]]:
                    top_i = s.pop()
                if len(s) > 0:
                  	# 这一段代码太复杂了！！！我大概花了一个小时才写出来！！
                    # 另外， s 存的是下标，别直接当值用了！真是个容易犯的错误！！                    
                    res += (min(height[i], height[s[-1]]) - height[top_i]) * (i - s[-1]-1)
        return res                
            

```

****



***

### 打印n位数 剑指offer12

```python
def f1(n):
    i = 1
    while i < 10 ** n:
        print(i)
        i += 1


n = 4
num = [0 for i in range(n)]

def add1():
    carry = 0
    for i in range(n-1, -1, -1): # 遍历num的位数
        if carry == 1 and i == 0 and num[i] == 9:
            return False
        if i == n-1:
            add_result = num[i] + 1 + carry
        else:
            add_result = num[i] + carry
        num[i] = add_result % 10
        carry = add_result // 10
        if carry == 0:
            break
    return True

def print_interger():
    while add1():
        flag = False
        print_num = []
        for i in range(n):
            if num[i] != 0:
                flag = True
            if flag:
                print_num.append(str(num[i]))
        print(''.join(print_num))

        # print(num)

print_interger()
```



改进版，合并成一个函数

```python
def print_interger(n):
    num = [0 for i in range(n)]
    carry = 0
    flag = True
    while flag:
        for i in range(n - 1, -1, -1):  # 遍历num的位数
            if carry == 1 and i == 0 and num[i] == 9:
                flag = False
            if i == n - 1:
                add_result = num[i] + 1 + carry
            else:
                add_result = num[i] + carry
            num[i] = add_result % 10
            carry = add_result // 10
            if carry == 0:
                break

        flag_bit = False
        print_num = []
        for i in range(n):
            if num[i] != 0:
                flag_bit = True
            if flag_bit:
                print_num.append(str(num[i]))
        print(''.join(print_num))

        # print(num)

print_interger(3)
```

****





### 字节跳动周赛

### 1417. 重新格式化字符串

给你一个混合了数字和字母的字符串 `s`，其中的字母均为小写英文字母。

请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。

请你返回 **重新格式化后** 的字符串；如果无法按要求重新格式化，则返回一个 **空字符串** 。

**示例 1：**

```
输入：s = "a0b1c2"
输出："0a1b2c"
解释："0a1b2c" 中任意两个相邻字符的类型都不同。 "a0b1c2", "0a1b2c", "0c2a1b" 也是满足题目要求的答案。
```

**示例 2：**

```
输入：s = "leetcode"
输出：""
解释："leetcode" 中只有字母，所以无法满足重新格式化的条件
```

```python
class Solution:
    def reformat(self, s: str) -> str:
        alphabets = []
        ints = []
        length = len(s)
        for i in range(length):
            if s[i] >= '0' and s[i] <= '9':
                ints.append(i)
            else:
                alphabets.append(i)
        len_dis = len(alphabets) - len(ints)
        if len_dis > 1 or len_dis < -1:
            return ''
        if len_dis >= 0:
            return self.helper(s, alphabets, ints)
        else:
            return self.helper(s, ints, alphabets)

    def helper(self, s, long, short):
        res = [0 for i in range(len(s))]
        j = 0
        for i in range(len(short)):
            res[j] = s[long[i]]
            j += 1
            res[j] = s[short[i]]
            j += 1
        if len(long) > len(short):
            res[j] = s[long[-1]]
        return ''.join(res)

case = "123456abcde"
res = Solution().reformat(case)
print(res)
```



### 字节跳动周赛 排列菜单

给你一个数组 `orders`，表示客户在餐厅中完成的订单，确切地说， `orders[i]=[customerNamei,tableNumberi,foodItemi]` ，其中 `customerNamei` 是客户的姓名，`tableNumberi` 是客户所在餐桌的桌号，而 `foodItemi` 是客户点的餐品名称。

请你返回该餐厅的 **点菜展示表** *。*在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。

注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。

**示例 1：**

```
输入：orders = [["David","3","Ceviche"],["Corina","10","Beef Burrito"],["David","3","Fried Chicken"],["Carla","5","Water"],["Carla","5","Ceviche"],["Rous","3","Ceviche"]]
输出：[["Table","Beef Burrito","Ceviche","Fried Chicken","Water"],["3","0","2","1","0"],["5","0","1","0","1"],["10","1","0","0","0"]] 
解释：
点菜展示表如下所示：
Table,Beef Burrito,Ceviche,Fried Chicken,Water
3    ,0           ,2      ,1            ,0
5    ,0           ,1      ,0            ,1
10   ,1           ,0      ,0            ,0
对于餐桌 3：David 点了 "Ceviche" 和 "Fried Chicken"，而 Rous 点了 "Ceviche"
而餐桌 5：Carla 点了 "Water" 和 "Ceviche"
餐桌 10：Corina 点了 "Beef Burrito" 
```

```python
from typing import List

class Solution:
    def displayTable(self, orders: List[List[str]]) -> List[List[str]]:
        table_order_map = {}
        for item in orders:
            if table_order_map.get(item[1]):
                item_map = table_order_map[item[1]]
                if item_map.get(item[2]):
                    item_map[item[2]] += 1
                else:
                    item_map[item[2]] = 1
            else:
                table_order_map[item[1]] = {}
                table_order_map[item[1]][item[2]] = 1
        items = set()
        for item in orders:
            items.add(item[2])
        count = len(items)

        res = []
        headline = []
        for food in items:
            headline.append(food)
        headline.insert(0, 'Table')

        for table, table_items in table_order_map.items():
            line = [0 for i in range(count + 1)]
            line[0] = table
            for i in range(1, count+1):
                if table_items.get(headline[i]):
                    line[i] = table_items.get(headline[i])
            res.append(line)
        res.sort(key=lambda x: x[1])

        res.insert(0, headline)
        return res
```



### 排列电话号码

```python

from typing import List


class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        _map = {
            '2': ['a', 'b', 'c'],
            '3': ['d', 'e', 'f'],
            '4': ['g', 'h', 'i'],
            '5': ['j', 'k', 'l'],
            '6': ['m', 'n', 'o'],
            '7': ['p', 'q', 'r', 's'],
            '8': ['t', 'u', 'v'],
            '9': ['w', 'x', 'y', 'z'],
        }
        res = []

        def helper(_prefix, i, digits):
            if i == len(digits):
                res.append(_prefix)
                return
            for letter in _map[digits[i]]:
                helper(_prefix + letter, i + 1, digits)

        helper('', 0, digits)
        return res


Solution().letterCombinations('23')

```





# 动态规划

动态规划思想分析见 



***

### 最长递增子序列 递增序列 leet300



#### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

难度中等669

给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**

```
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

**说明:**

- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为 O(*n2*) 。

**进阶:** 你能将算法的时间复杂度降低到 O(*n* log *n*) 吗?



正确的解法

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        length = len(nums)
        if length == 0: return 0
        dp = [1 for i in range(length)] # dp[i]表示包含nums[i]在内的子数组中最长的子序列的长度
        for i in range(1, length):
            for j in range(i-1, -1, -1): # 从后往前遍历，遍历 i 之前的数
                # 如果 nums[i] > nums[j]，那么递增序列有可能增长，但不一定
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j]+ 1) 
        return max(dp)   
      
      
```


例如：[10,9,2,5,3,7,101,18]
****



***
### 摇筛子(骰子)结果统计

```python
# 先用递归做一遍，然后待会在用动态规划做
memo = {}
def f1(_sum, cur, memo, n): # 一共需要4个参数，要先想好。
    if cur == n:
        memo[_sum] = memo.get(_sum, 0) + 1
        return
    for i in range(1, 7):
        f1(_sum+i, cur+1, memo, n)


def stat(): # 统计结果，根据memo数组
    the_sum = 0
    res = []
    for k in memo.keys():
        the_sum += memo.get(k)
    for k in memo.keys():
        rate = int (memo.get(k) / the_sum * 10 ** 4) / 10 ** 4 # 保留4位小数
        res.append((k, rate))
    return res


f1(0, 0, memo, 2)
print(memo)
res = stat()
print(res)
rate_sum = 0
for item in res:
    rate_sum += item[1]
print(rate_sum)
```

#### 动态规划方法

```python
# 对比发现，动态规划用了32行代码，而递归则只用了17行代码，递归具有巨大的优越性！！在面试的时候建议优先使用递归来做，递归的思路就是穷举
def dice_play(n):
    res = []
    length = 6*n+1
    dp = [0 for i in range(length)]
    for i in range(1, 1+6):
        dp[i] += 1
    print(dp)
    # 如果投了两次以及两次以上
    time = 1
    while time < n:
        dp2 = [0 for i in range(length)]
        for i in range(1, 1+6):
            for j in range(length):
                if dp[j] != 0:
                    dp2[j+i] += dp[j]

        print(dp2)
        dp = dp2 # 让 dp 指向 dp2
        time += 1
    
    if n == 1:
        dp2 = dp
    the_sum = 0
    for i in range(length):
        if dp2[i] != 0:
            the_sum += dp2[i]
    for i in range(length):
        if dp2[i] != 0:
            res.append([i, dp2[i]/the_sum])
    return res

res = dice_play(1)
print(res)



```
****

***
### 牛妹的礼物

```python
class Solution:

    def selectPresent(self, presentVolumn):
        if not presentVolumn: return 0
        self.N = len(presentVolumn)
        self.M = len(presentVolumn[0])
        self.weight = presentVolumn[0][0]
        self.presentVolumn = presentVolumn
        self.memo = [[-1 for i in range(self.M)] for j in range(self.N)]
        self.walk(0, 0, self.weight)
        return self.weight

    N = 0
    M = 0
    weight = 0
    presentVolumn = None
    memo = []

    def walk(self, n, m, cur_weight):
        # 利用兼职法
        if self.memo[n][m] == -1:
            self.memo[n][m] = cur_weight
        elif cur_weight < self.memo[n][m]:
            self.memo[n][m] = cur_weight
        else:
            return
        if n == self.N - 1 and m == self.M - 1:
            if self.weight == self.presentVolumn[0][0]:
                self.weight = cur_weight
            else:
                self.weight = min(cur_weight, self.weight)
            return

        if n+1 < self.N and m+1 < self.M:
            self.walk(n + 1, m + 1, cur_weight + self.presentVolumn[n+1][m+1])
        if n + 1 < self.N and m < self.M:
            self.walk(n + 1, m, cur_weight + self.presentVolumn[n+1][m])
        if n < self.N and m + 1 < self.M:
            self.walk(n, m + 1, cur_weight + self.presentVolumn[n][m+1])
```
****

***

### leetcode416 等和子集

#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

难度中等259

给定一个**只包含正整数**的**非空**数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**注意:**

1. 每个数组中的元素不会超过 100
2. 数组的大小不会超过 200

**示例 1:**

```
输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
```

 

**示例 2:**

```
输入: [1, 2, 3, 5]
输出: false
解释: 数组不能分割成两个元素和相等的子集.
```

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        the_sum = 0
        for num in nums:
            the_sum += num
        if the_sum & 1 == 1: return False
        dp_len = the_sum//2 + 1 # 如果有值可以等于一半，说明可以分割成两部分
        dp = [False for i in range(dp_len)]
        dp[0] = True
        for item in nums:
            if item >= dp_len: # 有值超过一半，肯定不行
                return False
            for i in range(dp_len-1, item-1, -1): 
                dp[i] = dp[i] or dp[i-item] # 这里还是不好懂的,起码第一眼看不出来为什么
                # 单词消耗
        return dp[dp_len-1]

```
****

通过这道题，收获了两个技巧：

第一，动态规划需要的空间复杂度越大，代码就越通俗易懂，如果非要压缩空间复杂度，那么代码就比较晦涩

第二，如果下标越界了，可以设置异常捕获机制，快速定位！！！

这道题，明显就压缩了空间复杂度，dp只使用了一维数组，那么就必须叠加使用，就非常的痛苦，如果我们使用两个数组，代码就通俗易懂的多。鉴于时间关系，我就不写了。

这道题，一下子很难想到动态规划，对于我来说，所以我也是参考了别人的答案。

***
### 打家劫舍最简单的版本

```python
class Solution:
    max_money = 0
    def rob(self, nums: List[int]) -> int:
        # 面对一间屋子，你有两种选择，抢或者不强
        # 抢的前提是上一间屋子没有抢
        # 不抢则是根据你的意愿决定，没有限制
        # 所以我们可以设计递归算法，传入两个参数，
        #   一个参数 flag 用来表示是否抢劫过前一间屋子
        #   另一个参数用来 num 表示当前抢劫了多少钱
        # 如果到走完所有的屋子，则返回当前抢的钱
        # 返回不同抢劫方法得到的最大值
        if nums == []: return 0
        self.choice(nums, 1, True, nums[0])
        self.choice(nums, 1, False, 0)
        return self.max_money
    
    def choice(self, nums, i, flag, money):
        length = len(nums)
        if i == length:
            # 更新最大值
            self.max_money = max(self.max_money, money)
            return 
        if flag == True: # 上间屋子抢劫过，跳过
            self.choice(nums, i+1, not flag, money)
        else: # 没有抢劫过，有两种选择
            self.choice(nums, i+1, flag, money)
            self.choice(nums, i+1, not flag, money + nums[i])
        # 容易超出时间限制，因为是暴力破解，无限穷举，但是这样很容易优化，增马迹一个memo字典即可    
```




#### 更简介的递归

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        memo = {}
        return self.helper(0, nums,memo)

    def helper(self, i, nums, memo):
        if i >= len(nums):
            return 0
        if memo.get(i): return memo.get(i)
        res = max(nums[i]+self.helper(i+2, nums, memo),
            self.helper(i+1, nums, memo)
        )
        memo[i] = res
        return res
```



#### 动态规划

```python
# 
class Solution: # 1

    def rob(self, nums: List[int]) -> int:
      	# 使用对动态规划的方式来思考，这是我第一次独立完成动态规划的题目，2020-03-10 09:58:09。。。。
        # 面对一间屋子，你有两种选择，抢或者不强
        # 抢的前提是上一间屋子没有抢
        # 不抢则是根据你的意愿决定，没有限制
        # 设计一个数组 dp[i][f]
        #   i表示第i个房屋
        #   f表示是否抢劫, f=0:不抢， f=1:抢
        #   dp[i][f]表示遍历当前房屋之后，最大的钱
        #   dp[i][0] = max(dp[i-1][0], dp[i-1][1])
        #   dp[i][1] = dp[i-1][0]+nums[i]
        #  递推公式是难点，要严格的推理！
        length = len(nums)
        if length == 0: return 0
        dp = [ [0, 0] for i in range(length) ]
        dp[0][0] = 0
        dp[0][1] = nums[0]
        for i in range(1, length):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1])
            dp[i][1] = dp[i-1][0] + nums[i]
        return max(dp[length-1][0], dp[length-1][1])
```

在Solution1的基础上，我们再改进一下，我们让 dp 保存 最大的元素

```python
class Solution:

    def rob(self, nums: List[int]) -> int:
        dp = [0 for i in range(len(nums)+2)]
        dp[0] = 0
        dp[1] = 0
        for i in range(2, len(dp)):
            dp[i] = max(dp[i-1], dp[i-2]+nums[i-2])
        return dp[-1]
```

我们进一步压缩空间

```python
class Solution:

    def rob(self, nums: List[int]) -> int:
        dp_0 = 0
        dp_1 = 0
        the_dp_i = 0
        for i in range(len(nums)):
            the_dp_i = max(dp_1, dp_0+nums[i])
            dp_0 = dp_1
            dp_1 = the_dp_i 
        return the_dp_i
```
****

***
###  打家劫舍2 环形

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 0: return 0
        if len(nums) == 1: return nums[0]
        return max(
            self.helper(nums[0:len(nums)-1]),
            self.helper(nums[1:])
            )
    
    def helper(self, nums: List[int]) -> int:
        dp_0 = 0
        dp_1 = 0
        the_dp_i = 0
        for i in range(len(nums)):
            the_dp_i = max(dp_1, dp_0+nums[i])
            dp_0 = dp_1
            dp_1 = the_dp_i 
        return the_dp_i
```
****

***
### 买股票系列 允许一次交易 

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 可以用递增栈来做，但是也可以用更加通用的方式来做，比如状态机
        # 本次就用状态机来做，也就是动态规划
        # 设置数组dp[i][k], 表示第i天最大利润
        #   i表示天数，从0开始
        #   k表示是否出售,0表示没有买入，1表示买入
        # d[i][0] = max(d[i-1][0], d[i-1][1] + prices[i])
        # d[i][1] = max(d[i-1][1],  - prices[i])
        # 
        #   解释为今天要么没有交易，保持和前一天一样，要么买入或者卖出
        #   买入则利润流出，卖出则利润流入
        # 初始状态为 d[0][0] = 0, dp[0][1] = -prices[0]
        # 
        # 返回 dp[n-1][0] 即可 
        #   因为dp[n-1][1]表示最后一天买入，没有卖出而不符合题意
        if prices is None or prices == []: return 0
        length = len(prices)        
        dp =  [ [0 for i in range(2)] for j in range(length) ]
        dp[0][0] = 0
        dp[0][1] = -prices[0]
        for i in range(1, length):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
            dp[i][1] = max(dp[i-1][1], - prices[i])
        return dp[length-1][0]
```

### 股票交易，含1天冷冻期

#### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

难度中等303

给定一个整数数组，其中第 *i* 个元素代表了第 *i* 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**示例:**

```
输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        length = len(prices)
        if length == 0: return 0
        dp = [ [0 for i in range(2)] for j in range(length+1) ]
        dp[1][0] = 0
        dp[1][1] = -prices[0]
        for i in range(2, length+1):
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i-1])
            dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i-1])
        return dp[-1][0]
```
****





***
### 定符号 leet494

```python
class Solution:
    def findTargetSumWays(self, nums: List[int], S: int) -> int:
        length = len(nums)
        dp = [ dict() for i in range(length)]
        dp[0][-nums[0]] = 1
        dp[0][+nums[0]] = dp[0].get(+nums[0], 0) + 1
        for i in range(1, length):
            for cur_sum, cnt in dp[i-1].items(): # 动态规划就是基于上一层层层叠加，状态转换，但是以本层为主，上一层只是加数，本层才是被加数！这点尤为重要，我浪费了40分钟在这上面
                 dp[i][cur_sum+nums[i]] = dp[i].get(cur_sum+nums[i], 0) + cnt
                 dp[i][cur_sum-nums[i]] = dp[i].get(cur_sum-nums[i], 0) + cnt
        return dp[length-1].get(S,0)
```



使用递归+备忘录的形式做的代码   基于Python语言超时了，但是基于C++语言没有问题

```python
class Solution:
    memo = None
    def findTargetSumWays(self, nums: List[int], S: int) -> int:
        self.memo = [dict() for i in range(len(nums))]
        res = self.helper(0, S, nums)
        return res
    
    def helper(self, i, left, nums):
        if i >= len(nums): 
            if left == 0: return 1
            return 0
        memo_v = self.memo[i].get(left)
        if memo_v:        
          memo_v.get(left)
        res = self.helper(i+1, left-nums[i], nums) + \
            self.helper(i+1, left+nums[i], nums)
        self.memo[i][left] = res
        return res
```
****

***
### leet322 零钱兑换

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        coins.sort()
        if amount==0: return 0
        cnt = amount // coins[0] + (0 if amount % coins[0] == 0 else 1)
        dp_1 = {0:0}             
        i = 1
        while i <= cnt:   
            dp_2 = {}            
            for k in dp_1:
                for c in coins:
                    dp_2[k+c] = 1
                    if k+c == amount:
                        return i
            dp_1 = dp_2
            i += 1
        return -1
```

这里，使用完整的状态机来做，但是可以使用更好的动态规划算法来压缩空间复杂度。

压缩了的算法

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [amount+1 for i in range(amount+1)]
        dp[0] = 0
        for i in range(1, amount+1): # i表示次数，amout是次数最大上限
            for c in coins:
                if i >= c:
                    dp[i] = min(dp[i], dp[i-c]+1) # 这一行代码其实和状态机逻辑不符，并不算进化
        return dp[amount] if dp[amount] != (amount+1) else -1
```
****

***
### 莱文斯坦编辑距离

回溯是一个递归处理的过程。如果 a[i]与 b[j]匹配，我们递归考察 a[i+1]和 b[j+1]。

如果 a[i]与 b[j]不匹配，那我们有多种处理方式可选：

可以删除 a[i]，然后递归考察 a[i+1]和 b[j]；

可以删除 b[j]，然后递归考察 a[i]和 b[j+1]；

可以在 a[i]前面添加一个跟 b[j]相同的字符，然后递归考察  a[i]和 b[j+1];

可以在 b[j]前面添加一个跟 a[i]相同的字符，然后递归考察 a[i+1]和 b[j]；

可以将 a[i]替换成 b[j]，或者将 b[j]替换成 a[i]，然后递归考察 a[i+1]和 b[j+1]。

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:        
        length1 = len(word1)
        length2 = len(word2)
        if length1 == 0: return length2 # 注意，必须考虑边界值，否则就会出问题
        if length2 == 0: return length1
        dp = [ [ 0 for i in range(length1) ] for j in range(length2) ]
        # 前两步，先初始化
        for i in range(0, length1):
          	# 使用 word1 第 i 个字符和 word2 第0个字符比较 
            if word1[i] == word2[0]: dp[0][i] = i # 比如第3个字符和word2[0]相等，那么编辑距离为i
            elif i==0: dp[0][i] = 1 #  第一个字母不相等的话，编辑距离即为1
            else: dp[0][i] = 1 + dp[0][i-1] # 
        for i in range(0, length2):
            if word2[i] == word1[0]: dp[i][0] = i
            elif i==0: dp[i][0] = 1
            else: dp[i][0] = 1 + dp[i-1][0]
        # 
        for j in range(1, length2):
            for i in range(1, length1):
                if word1[i] == word2[j]: dp[j][i] = dp[j-1][i-1]
                else:
                    dp[j][i] = min(dp[j-1][i], dp[j][i-1], dp[j-1][i-1]) +1
        return dp[length2-1][length1-1]
      
"pneumonoultramicroscopicsilicovolcanoconiosis"
"ultramicroscopically"      

```


递归代码

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        len1 = len(word1)
        len2 = len(word2)
        def helper(i, j):
            if i >= len1:
                return len2 - j
            if j >= len2:
                return len1 - i
            if word1[i] == word2[j]:
                return helper(i+1, j+1)
            else:
                return min(helper(i, j+1), helper(i+1, j), helper(i+1, j+1))+1
        return helper(0, 0)
```
****





***
### 最长公共序列 leet1143

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        len1 = len(text1)
        len2 = len(text2)
        memo = {}
        def helper(i, j): # 无法无天的语言了！
            if i < 0 or j < 0: return 0
            if memo.get((i, j)):
                return memo.get((i, j))
            v = 0
            if text1[i] == text2[j]: 
                v =  1+ helper(i-1, j-1)
            else:
                v = max(helper(i-1, j), helper(i, j-1))
            memo[(i, j)] = v
            return v
        return helper(len1-1, len2-1)
```
****

***
### [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

难度中等300

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

输入: 2
输出: [0,1,1]
示例 2:

输入: 5
输出: [0,1,1,2,1,2]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/counting-bits
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```python
class Solution:
    def countBits(self, num: int) -> List[int]:
        if num == 0:
            return [0]
        if num == 1:
            return [0, 1]
        if num == 2:
            return [0, 1, 1]
        length = num+1
        res = [0 for i in range(length)]
        res[1] = 1
        res[2] = 1
        i2 = 1
        i = 3
        while i < length:
            while i < length and (1 << i2) < i < (1 << (i2+1)):
                res[i] = res[i-(1<<i2)] + 1
                i += 1
            if i < length and i == (1 << i2 + 1):
                res[i] = 1
                i += 1
            i2 += 1
        return res

```
****





# 树
***
### 平衡树

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        flag, height = self.is_balance(root)
        return flag

    def is_balance(self,root):
        if root is None: return True, 0
        if root.left is None and root.right is None: return True, 1
        flag_l, height_l = self.is_balance(root.left)
        flag_r, height_r = self.is_balance(root.right)
        # 已经出现不平衡
        if not (flag_l and flag_r):
            return False, -1
        if flag_l and flag_r and abs(height_l - height_r) > 1:
            return False, -1
        else:
            return True, max(height_l, height_r) + 1
```



这里使用了后序遍历法，只遍历了一次，又兼顾处理了高度和是否平衡的问题，一举两得，非常的巧妙。



下面就代码进一步进行了压缩。

```python
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        flag, height = self.is_balance(root)
        return flag

    def is_balance(self,root):
        if root is None: return True, 0
        if root.left is None and root.right is None: return True, 1
        flag_l, height_l = self.is_balance(root.left)
        flag_r, height_r = self.is_balance(root.right)
        if flag_l and flag_r and abs(height_l - height_r) <= 1:
            return True, max(height_l, height_r) + 1
        else:
            return False, -1
```
****

***
### 树的直径

543. 二叉树的直径
给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    memo = {}

    def height(self, root):
        # 每棵结点都是一棵树，这结点就是这个树的根结点
        # 树的高度是它的根结点到它的叶结点的最大距离， 即左右子树中更大高度的那棵树的值再加1
        # 定义一个函数，来计算树的高度
        if root is None: return 0   
        # 查记忆表
        if self.memo.get(root):
            return self.memo.get(root)
        if root.left is None and root.right is None: 
            self.memo[root] = 1
            return 1            
        h =   max(self.height(root.left), self.height(root.right)) + 1
        self.memo[root] = h  
        return h

    def diameterOfBinaryTree(self, root: TreeNode) -> int:

        # 1 一个树的直径是由左子树的高度+右子树的高度之和
        # 2 分别求出左右子树的高度，并加起来得到该树的高度
        # 3 继续遍历求 左子树的直径和右子树的直径并且比较得到最大的直径并返回
        # 4 如果一个树的根为空或者本身就是叶结点，那么它的直径为0
        if root is None: return 0
        if root.left is None and root.right is None: return 0
        h_l = self.height(root.left)
        h_r = self.height(root.right)
        dia = h_l + h_r
        dia_l = self.diameterOfBinaryTree(root.left)
        dia_r = self.diameterOfBinaryTree(root.right)
        return max(dia, dia_l, dia_r)

```
****

***
### leet617 树的合并

#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

难度简单360

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则**不为** NULL 的节点将直接作为新二叉树的节点。

**示例 1:**

```
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```





```python
class Solution(object):
    def mergeTrees(self, t1, t2):
        if not t1 and not t2:
            return None
        elif not t1:
            return t2 # 直接返回, 不再新创建结点. 
        elif not t2:
            return t1
        t1.val += t2.val
        t1.left = self.mergeTrees(t1.left, t2.left)
        t1.right = self.mergeTrees(t1.right, t2.right)
        return t1
        
```

### 从树的中序遍历、前序遍历重新构建树

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        the_map = {}
        length = len(preorder)
        for i in range(length): # 建立一个中序遍历的 map，k=元素序号，v=下标，假定没有值相等的元素
            the_map[inorder[i]] = i
        
        def build_helper(pre_start, pre_end, in_start): # 左子树的起点必须要有
            if pre_start > pre_end:
                return None
            if pre_start == pre_end:
                return TreeNode(preorder[pre_start])
            root = TreeNode(preorder[pre_start]) # 从前序遍历序列获取根结点
            root_index = the_map[preorder[pre_start]] # 获取中序遍历根节点的下标
            left_tree_length = root_index - in_start # 左子树的长度
            root.left = build_helper(pre_start+1, pre_start+left_tree_length, in_start)
            root.right = build_helper(pre_start + left_tree_length + 1, pre_end, root_index + 1) # pre_start + left_tree_length + 1 非常重要！！！
            return root
        res = build_helper(0, length-1, 0) 
        return res
```
****

***
### 树的翻转

```go
func invertTree(root *TreeNode) *TreeNode {
  if root == nil || (root.Left == nil && root.Right == nil) {
    return root
  }
  root.Left, root.Right = invertTree(root.Right), invertTree(root.Left)
  return root
}
```
****




# 排序
***
### 旋转数组的排序 leet153, 支持重复数字

#### [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

难度中等180

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

请找出其中最小的元素。

你可以假设数组中不存在重复元素。

**示例 1:**

```
输入: [3,4,5,1,2]
输出: 1
```

**示例 2:**

```
输入: [4,5,6,7,0,1,2]
输出: 0
```

```python
class Solution:
    def findMin(self, nums: List[int]) -> int:
        # 寻找旋转的边界， 形成两段有序数组的模型
        length = len(nums)
        l, r = 0, length - 1
        while True:
            # 我们认为，如果左指针的值大于
            if nums[l] < nums[r]:
                return nums[l]
            if l + 1 == r:
                return min(nums[l], nums[r])
            mid = (l + r) // 2
            if nums[mid] == nums[l] and nums[mid] == nums[r]:
                minv = nums[l]
                while l <= r:
                    minv = min(minv, nums[l])
                    l += 1
                return minv
            elif nums[mid] >= nums[l]:  # 左边多
                l = mid
            elif nums[mid] < nums[l]:
                r = mid
```


```python
# 这个解更好更短
class Solution:
    def findMin(self, nums: List[int]) -> int:
        length = len(nums)
        l, r = 0, length - 1
        while l < r:
            if nums[l] < nums[r]:
                return nums[l]
            if r - l == 1:
                return min(nums[l], nums[r])
            mid = (l + r)//2
            if nums[mid] >= nums[l]:
                l = mid
            else:
                r = mid
        return nums[l]

```
****




# 递归

### 如何把全局变量变成局部变量

```python
# demo1
a = 1
def f1():
    global a
    a += 1

def f2():
    global a
    a += 2


f1()
f2()
print(a)
```

```python
# demo2在demo1的基础上
def f1(a): # 传入
    a += 1
    return a # 返回

def f2(a):
    a += 2
    return a

a = 1
a = f1(a) # 链式调用
a = f2(a)
print(a)
```

```python
# demo3在demo1的基础上，自己本身需要一个参数
a = 1
def f1(b):
    global a
    a += b

def f2(b):
    global a
    a += b

f1(2)
f2(3)
print(a)
```

```python
# demo4在demo2和demo3的基础上，取消了全局变量
def f3(b, a): # 传入
    a += b
    return a # 返回，一般只能返回一个值

def f4(b, a):
    a += b
    return a

aa = 10
aa = f3(1, aa)
aa = f4(2, aa)
print(aa)
```

```python
# 实战应用，首先是二叉搜索树转链表，我们使用了两个全局变量来实现算法
import lib
# ls = [1, 2, 3, 4, 5, 6, 7]
ls = [4, 2, 6, 1, 3, 5, 7]
tree = lib.list_to_tree(ls) # 根据一个完全二叉树的层序遍历序列把它再次转化成一个树，我自己写的，不是内置库


head = None
pre = None
def traverse(root):
    if root is None:
        return
    global head, pre
    traverse(root.left)

    root.left = pre
    if pre is None:
        head = root
    else:
        pre.right = root
    pre = root

    traverse(root.right)


def tree_to_dlkls(root): # tree to double linked list
    """
    树转双链表
    :param root:
    :return:
    """
    traverse(root)


tree_to_dlkls(tree)
while head: # 打印输出
    print(head.val, end=',')
    head = head.right


```



```python
# 改造成没有全局变量的函数
import lib
ls = [1, 2, 3, 4, 5, 6, 7]
# ls = [4, 2, 6, 1, 3, 5, 7]
tree = lib.list_to_tree(ls)

def traverse(root, pre, head):
    if root is None:
        return pre, head
    pre, head = traverse(root.left, pre, head) # 右边的pre被修改了，然后再返回回来，依靠这种链式设计，可以实现一个参数的层层传递，从而干掉全局变量

    root.left = pre
    if pre is None:
        head = root
    else:
        pre.right = root
    pre = root

    pre, head = traverse(root.right, pre, head) 
    return pre, head


def tree_to_dlkls(root):
    """
    树转双链表
    :param root:
    :return:
    """
    pre, head = traverse(root, None, None)
    return head


head = tree_to_dlkls(tree)
while head:
    print(head.val, end=',')
    head = head.right

```

***
### leet394 字符串解码

```python
class Solution:                                                                    
    def decodeString(self, s: str) -> str:                                         
        # 重复子问题，非常适合用递归来做                                                          
        if not s:return ''                                                         
        if not '[' in s:return s                                                   
        i = 0                                                                      
        length = len(s)    
        # 普通字母
        if i < length and ( s[i] < '0' or s[i] > '9' ):                            
            j = i                                                                  
            while j < length and ( s[j] < '0' or s[j] > '9' ):                     
                j += 1                                                             
            return s[i:j] + self.decodeString(s[j:])                               
        # 数字
        count = 0         
        while i < length and s[i] >= '0' and s[i] <= '9':                          
            count =  count*10 + int(s[i])                                          
            i += 1                                                                 
        j = i+1 # 左括号                                                                   
        l_pc = 0 #                                                                
        while j < length:                                                          
            if s[j] == '[': l_pc += 1                                              
            elif s[j] == ']' and l_pc > 0: l_pc -= 1                               
            elif s[j] == ']': break # 找到与之匹配的右括号，结束                                                
            j += 1                                                                 
        return count * self.decodeString(s[i+1:j]) + self.decodeString(s[j+1:])    
```

这道题我浪费了很长时间，思路是对的，但是败给了细节，2020-04-19 09:13:16

这是一个明显的重复子问题，可以通过递归降低问题规模来解决。
****








# 双指针
***
### 3sum leet15

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        # 先排序，然后固定一个数字，再用双指针找
        length = len(nums) # 假设元素至少为3个
        res = []
        nums.sort() 
        for i in range(length-2):
            if i > 0 and nums[i] == nums[i-1]: # 去重
                continue
            l, r = i + 1, length-1
            while l < r:
                total = nums[i] + nums[l] + nums[r]
                if total == 0:
                    res.append((nums[i], nums[l], nums[r]))                 
                    l += 1   
                    while nums[l] == nums[l-1] and l < r: l+=1 # 去重             
                    r -= 1
                    while nums[r] == nums[r+1] and l < r: r-=1 # 去重
                elif total > 0:
                    r -= 1
                else:
                    l += 1
        return res
```
****


# 字符串
***
### 异位词分组 leet49

#### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

难度中等329

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

**示例:**

```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

**说明：**

- 所有输入均为小写字母。
- 不考虑答案输出的顺序。

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        group_map = {}
        res = []
        for i in range(len(strs)):
          	# 首先， 把所有的词都按其内部字母顺序排个序，得到一个新的字符串，记为 item_sorted
            item = strs[i]
            item_sorted = list(item)
            item_sorted.sort()
            item_sorted = ''.join(item_sorted)
            # 然后 每次遍历一个单词时，以item_sorted为键去查询和存储是否有对应的位置  
            if group_map.get(item_sorted):
                group_map[item_sorted].append(i)
            else:
                group_map[item_sorted] = [i]
        for k in group_map:
            res.append( [strs[i] for i in group_map.get(k) ] )
        return res
```
****




#  括号匹配
***
## leet301 本机能通过，网页单例测试通过，提交无法通过 leetcode cn

用例："(a)())()"，"()())()"，")("

```python
# 
from typing import List

res = []  # 返回的结果集，使用一个全局变量保存


def is_valid(the_str):
    """
    the_str: 输入的字符串

    判断输入的字符是否合法，时间复杂度是O(n)，空间复杂度是O(1),没有使用栈
    """
    lc = rc = 0
    for item in the_str: # 分别统计不合法的左右括号
        if item == '(':
            lc += 1
        elif item == ')':
            if lc > 0:
                lc -= 1
            else:
                rc += 1
                return False
    if lc == 0 and rc == 0:
        return True
    return False


def dfs(the_str, i, lc, rc):
    """
    the_str: 当前待处理的字符串，可能已经删掉原始字符串某个位置的从开始到结束的完整的字符
    i: 当前遍历位置
    lc: 非法的左括号数量
    rc: 非法的右括号数量
    """
    if lc == 0 and rc == 0:
        if is_valid(the_str): # 这里的检测是否有必要呢？有必要，因为有可能减掉了一个合法的位置的串而导致不合法，我们只能数清楚不合法的左右字符串的数量，但是无法确定他们的位置！
            res.append(the_str)
        return
    from_i = i
    for i in range(len(the_str)):
        if i > from_i and the_str[i] == the_str[i - 1]:
            continue
        if lc > 0 and the_str[i] == '(':
            dfs(the_str[0:i] + the_str[i + 1:], i, lc - 1, rc)
        elif rc > 0 and the_str[i] == ')':
            dfs(the_str[0:i] + the_str[i + 1:], i, lc, rc - 1)


class Solution:
    def removeInvalidParentheses(self, s: str) -> List[str]:
        lc = rc = 0  # 不合法括号的数量
        for item in s:
            if item == '(':
                lc += 1
            elif item == ')':  # 含有其他字符，比如字母a
                if lc > 0:
                    lc -= 1
                else:
                    rc += 1
        dfs(s, 0, lc, rc)
        return res

res = Solution().removeInvalidParentheses("(a)())()")
print(res)
```
****


# 子数组
***
### leet560 连续子数组的和

#### [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

难度中等299

给定一个整数数组和一个整数 **k，**你需要找到该数组中和为 **k** 的连续的子数组的个数。

**示例 1 :**

```
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```

**说明 :**

1. 数组的长度为 [1, 20,000]。
2. 数组中元素的范围是 [-1000, 1000] ，且整数 **k** 的范围是 [-1e7, 1e7]。

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        length = len(nums)
        memo = {}
        memo[0] = 1
        the_sum = 0
        res = 0
        for i in range(length):
            the_sum += nums[i] # 表示逐项累和
            # memo 存贮着所有以0下标开头的子数组之和，如果memo[the_sum-k]存在，则说明
            # 存在着从0到i的当前子数组去掉 从0到x的某一截子数组 剩下的那段子数组之和刚好等于 k
            res += memo.get(the_sum-k , 0)  
            memo[the_sum] = memo.get(the_sum, 0) + 1
        return res
```
****


# 图
***
##  BFS

这个不是基本的广度优先遍历，而是最少步数的广度遍历优先。

```
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj())
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
        }
        /* 划重点：更新步数在这里 */
        step++;
    }
}
```
****

***
### 200. 岛屿数量

https://leetcode-cn.com/problems/number-of-islands/

难度中等557

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

**示例 1:**

```
输入:
11110
11010
11000
00000
输出: 1
```

**示例 2:**

```
输入:
11000
11000
00100
00011
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。
```



```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        m = len(grid)
        if m == 0:
            return 0
        n = len(grid[0])
        if n == 0:
            return 0
        
        def helper(i, j):
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':
                return
            grid[i][j] = '2'
            helper(i+1, j)
            helper(i-1, j)
            helper(i, j-1)
            helper(i, j+1)
        
        res = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j] == '1':
                    helper(i, j)
                    res += 1
        return res

```
****



***
### DAG的检测 leet207

```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        # DAG图的检测
        # 1. 邻接表的建立
        # 2. 入度表的建立
        adjacency = {}
        indgrees = [0 for i in range(numCourses)]
        queue = []
        for item in prerequisites:
            if adjacency.get(item[1]):
                adjacency[item[1]].append(item[0])
            else:
                vetex = []
                vetex.append(item[0])
                adjacency[item[1]] = vetex
            indgrees[item[0]] += 1 # 入度加1
        for i in range(numCourses):
            if indgrees[i] == 0: # 这点特别重要，入度为0，表示起点
                queue.append(i)
        while len(queue) > 0:
            head = queue.pop(0) # 队头
            for i in adjacency.get(head,[]):
                if indgrees[i] > 0:
                    indgrees[i] -= 1
                if indgrees[i] == 0:
                    queue.append(i)
        for item in indgrees:
            if item > 0:
                return False
        return True
```



重写，如果是字母依赖而非数字依赖的话

```python
depens = [['A', 'B'], ['A', 'C'], ['B', 'D'], ['D', 'A']]
depens = [['A', 'B'], ['B', 'C'], ['C', 'B']]

def dag_check(depens):
    # step1: 建立邻接表
    # step2: 扫描邻接表,建立入度表
    # step3: 找一个入度为0的结点,也就是起点开始遍历
    adjacency = {}
    in_degree = {}
    for item in depens:
        if adjacency.get(item[0]):
            adjacency[item[0]].append(item[1])
        else:
            adjacency[item[0]] = [item[1]]

    for item in depens:
        in_degree[item[0]] = in_degree.get(item[0], 0)
        in_degree[item[1]] = in_degree.get(item[1], 0) + 1

    queue = []
    for k, v in in_degree.items():
        if v == 0:
            queue.append(k)

    while queue:
        head = queue.pop(0)
        to_vetexes = adjacency.get(head, [])
        for v in to_vetexes:
            if in_degree[v] > 0:
                in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)

    for k, v in in_degree.items():
        if v > 0:
            return False
    return True

if __name__ == '__main__':
    res = dag_check(depens)
    print(res)



```
****


# 矩阵

### leetcode48 leet48

旋转矩阵，先转置，再左右对称翻转

```
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        length = len(matrix)
        for i in range(length):
            for j in range(i):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        
        for i in range(length):
            for j in range(length//2):            
                matrix[i][j],matrix[i][length-1-j] = matrix[i][length-1-j],matrix[i][j]

```





